---
globs: "apps/frontend-*/**/*.service.ts, libs/**/frontend/**/*.service.ts, apps/frontend-*/**/*.actions.ts, libs/**/frontend/**/*.actions.ts, apps/frontend-*/**/*.reducers.ts, libs/**/frontend/**/*.reducers.ts, apps/frontend-*/**/*.effects.ts, libs/**/frontend/**/*.effects.ts, apps/frontend-*/**/*.selectors.ts, libs/**/frontend/**/*.selectors.ts, apps/frontend-*/**/*.facade.ts, libs/**/frontend/**/*.facade.ts"
alwaysApply: false
---

# Frontend Data-Access Rules (Angular + NgRx)

This ruleset governs frontend data-access libraries including services, facades, and NgRx artifacts (actions, reducers, effects, selectors). It aligns with the monorepo application and testing guidelines.

> The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” are as described in RFC 2119.

## Architecture

- Data-access **MUST** be the single source of truth for domain data and API integration.
- Components **MUST NOT** interact with the store or HTTP directly; use facades/services.
- Facades **MUST** expose a typed, domain-specific API (observables/selectors, commands/methods).
- Effects **MUST** encapsulate side effects (HTTP, routing, analytics) and be idempotent where possible.

## NgRx Artifacts

- **Actions**: **MUST** be created with `createAction` and typed payloads; group by domain/use-case.
- **Reducers**: **MUST** be pure, handle all action branches, and maintain immutable state updates.
- **Selectors**: **MUST** be memoized and strongly typed; derive data, do not compute heavy logic in components.
- **Effects**: **MUST** use `concatMap`/`exhaustMap`/`switchMap` appropriately; **SHOULD** include error handling and completion actions.

## Services & HTTP

- Services **MUST** isolate HTTP and map DTOs to domain models.
- Retry/backoff and caching **SHOULD** be implemented where appropriate; avoid silent failures.
- Input validation and output sanitization **MUST** be applied at boundaries.

## Error & Loading States

- State **MUST** include explicit `loading` and `error` fields for async flows.
- Effects **SHOULD** emit start/success/failure actions to update status fields.

## Testing

- Actions, reducers, and selectors **MUST** have unit tests for happy paths and edge cases.
- Effects **MUST** be tested with marble tests covering success, error, and cancellation.
- Services **SHOULD** mock HTTP and verify mapping, errors, and retries.

## Dependency Boundaries

- Data-access **MUST NOT** import from components or UI libraries.
- Cross-domain communication **MUST** occur via shared contracts or events, not direct imports.

## Examples

```ts
// users.actions.ts
export const loadUsers = createAction('[Users] Load');
export const loadUsersSuccess = createAction('[Users] Load Success', props<{ users: User[] }>());
export const loadUsersFailure = createAction('[Users] Load Failure', props<{ error: string }>());
```

```ts
// users.reducer.ts
export interface UsersState { entities: User[]; loading: boolean; error?: string }
export const initialState: UsersState = { entities: [], loading: false };
export const usersReducer = createReducer(
  initialState,
  on(loadUsers, (s) => ({ ...s, loading: true, error: undefined })),
  on(loadUsersSuccess, (s, { users }) => ({ ...s, loading: false, entities: users })),
  on(loadUsersFailure, (s, { error }) => ({ ...s, loading: false, error }))
);
```

```ts
// users.effects.ts
@Injectable()
export class UsersEffects {
  load$ = createEffect(() => this.actions$.pipe(
    ofType(loadUsers),
    switchMap(() => this.api.getUsers().pipe(
      map(users => loadUsersSuccess({ users })),
      catchError(err => of(loadUsersFailure({ error: this.normalizeError(err) })))
    ))
  ));
  constructor(private actions$: Actions, private api: UsersService) {}
  private normalizeError(err: unknown): string { return 'Unexpected error'; }
}
```

```ts
// users.selectors.ts
export const selectUsersState = createFeatureSelector<UsersState>('users');
export const selectUsers = createSelector(selectUsersState, s => s.entities);
export const selectLoading = createSelector(selectUsersState, s => s.loading);
```

```ts
// users.facade.ts
@Injectable({ providedIn: 'root' })
export class UsersFacade {
  readonly users$ = this.store.select(selectUsers);
  readonly loading$ = this.store.select(selectLoading);
  load(): void { this.store.dispatch(loadUsers()); }
  constructor(private store: Store) {}
}
```
