---
globs: "apps/backend-*/**/*.controller.ts, libs/**/backend/**/*.controller.ts, apps/backend-*/**/*.service.ts, libs/**/backend/**/*.service.ts, apps/backend-*/**/*.module.ts, libs/**/backend/**/*.module.ts"
alwaysApply: false
---

# Backend API Rules (NestJS)

This ruleset governs backend API modules, controllers, and services (NestJS). It aligns with domain boundaries and testing/security guidelines.

> The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” are as described in RFC 2119.

## Architecture

- Controllers **MUST** remain thin: validate input, authorize, and delegate to services.
- Services **MUST** encapsulate business logic and data orchestration; prefer CQRS for complex domains.
- Modules **MUST** define clear providers/imports/exports and avoid circular dependencies.

## Validation & Security

- DTOs **MUST** use class-validator and class-transformer; enable global validation pipes.
- Endpoints **MUST** enforce authentication and authorization where required.
- All routes **MUST** use HTTPS in production and avoid leaking sensitive data in errors.

## Error Handling

- Services **SHOULD** throw typed exceptions (e.g., `NotFoundException`, `BadRequestException`).
- Global filters/interceptors **SHOULD** standardize error responses and logging with correlation IDs.

## Performance & Resilience

- Use caching, pagination, and projections to minimize payloads.
- External calls **SHOULD** implement timeouts, retries, and circuit breakers.

## Testing

- Controllers **MUST** have request/response tests (Supertest or unit with testing module).
- Services **MUST** include unit tests covering business rules and edge cases.
- Modules **SHOULD** have integration tests for wiring and provider graphs.

## Dependency Boundaries

- Backend code **MUST NOT** import frontend libraries; use shared contracts only.
- Domain separation **MUST** be maintained; cross-domain calls **SHOULD** occur via contracts/events.

## Examples

```ts
// users.controller.ts
@Controller('users')
export class UsersController {
  constructor(private readonly service: UsersService) {}
  @Get(':id')
  get(@Param('id', new ParseUUIDPipe({ version: '4' })) id: string) {
    return this.service.getById(id);
  }
  @Post()
  create(@Body() dto: CreateUserDto) { return this.service.create(dto); }
}
```

```ts
// create-user.dto.ts
export class CreateUserDto {
  @IsEmail() email!: string;
  @IsString() @MinLength(2) name!: string;
}
```

```ts
// users.service.ts
@Injectable()
export class UsersService {
  constructor(private readonly repo: UsersRepository) {}
  getById(id: string) { return this.repo.findByIdOrThrow(id); }
  create(dto: CreateUserDto) { return this.repo.create(dto); }
}
```
