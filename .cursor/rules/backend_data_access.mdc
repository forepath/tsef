---
globs: "apps/backend-*/**/*.repository.ts, libs/**/backend/**/*.repository.ts, apps/backend-*/**/*.entity.ts, libs/**/backend/**/*.entity.ts, apps/backend-*/**/*.dto.ts, libs/**/backend/**/*.dto.ts"
alwaysApply: false
---

# Backend Data-Access Rules (Repositories, Entities, DTOs)

Back-end data-access abstracts persistence and transport boundaries while enforcing domain invariants.

> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" are as described in RFC 2119.

## Design & Boundaries

- Repositories **MUST** expose intention-revealing methods and hide ORM specifics.
- Entities **MUST** encapsulate invariants and domain behavior; avoid anemic models where feasible.
- DTOs **MUST** represent transport shapes and be validated at API boundaries.
- Data-access **MUST NOT** import frontend code; depend only on shared contracts and backend utilities.

## Mapping & Validation

- Mapping between DTOs and entities **MUST** be explicit and tested.
- Input validation **MUST** occur at boundaries; sanitize outputs to avoid leaking sensitive fields.

## Performance & Transactions

- Repositories **SHOULD** use pagination, projections, and indexes; avoid N+1 queries.
- Transactions **SHOULD** be used for multi-step consistency; apply optimistic locking when applicable.

## Testing

- Repositories **SHOULD** have integration tests against a test database or containers.
- Entities **SHOULD** have unit tests for invariants and domain rules.

## Examples

```ts
// users.repository.ts
@Injectable()
export class UsersRepository {
  constructor(private readonly orm: EntityManager) {}
  async findByIdOrThrow(id: string): Promise<UserEntity> {
    const user = await this.orm.findOne(UserEntity, { id });
    if (!user) throw new NotFoundException('User not found');
    return user;
  }
  create(dto: CreateUserDto) { return this.orm.save(UserEntity, this.mapToEntity(dto)); }
  private mapToEntity(dto: CreateUserDto): UserEntity { return Object.assign(new UserEntity(), dto); }
}
```

```ts
// user.entity.ts
@Entity('users')
export class UserEntity {
  @PrimaryGeneratedColumn('uuid') id!: string;
  @Column({ unique: true }) email!: string;
  @Column() name!: string;
  activate() { /* domain behavior */ }
}
```

```ts
// create-user.dto.ts
export class CreateUserDto { @IsEmail() email!: string; @IsString() name!: string }
```
