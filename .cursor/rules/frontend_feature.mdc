---
globs: "libs/**/frontend/**/feature/**/*.{routes.ts,route.ts,guard.ts,resolver.ts}, libs/**/frontend/**/feature/**/*.container.ts, apps/frontend-*/src/app/**/*.{routes.ts,route.ts,guard.ts,resolver.ts}, apps/frontend-*/src/app/**/*.container.ts, libs/**/frontend/**/feature/**/*.html, libs/**/frontend/**/feature/**/*.scss, apps/frontend-*/src/app/**/*.html, apps/frontend-*/src/app/**/*.scss"
alwaysApply: false
---

# Frontend Feature Rules (Angular Feature Libraries & App Features)

Feature code orchestrates workflows, routing, and facades; components here are container-orientated and coordinate UI + data-access.

> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" are as described in RFC 2119.

## Architecture

- Feature containers **MUST** depend on facades from `data-access` libraries and **MUST NOT** access the NgRx store directly.
- Feature containers **SHOULD** remain thin: wire inputs/outputs to UI components and invoke facade commands.
- Routing and guards **SHOULD** live in features and be strongly typed.

## State & Effects

- Side effects **MUST NOT** live in components; effects belong in `data-access`.
- Error and loading states **MUST** be represented in view-models derived from facades/selectors.

## Composition

- Prefer composing reusable UI components from `ui` libraries; avoid duplicating presentational code.

## Testing

- Container components **SHOULD** be tested for interaction with facades and routing.
- Route guards/resolvers **SHOULD** have unit tests for allow/deny and error paths.

## Examples

```ts
// users.routes.ts
export const routes: Routes = [
  { path: '', component: UsersContainerComponent, canActivate: [UsersLoadedGuard] },
];
```

```ts
// users.container.ts
@Component({ selector: 'app-users', template: `<app-users-list [users]="vm$ | async"></app-users-list>` })
export class UsersContainerComponent {
  readonly vm$ = combineLatest([
    this.facade.users$,
    this.facade.loading$,
  ]).pipe(map(([users, loading]) => ({ users, loading })));
  constructor(private readonly facade: UsersFacade) { this.facade.load(); }
}
```

```ts
// users-loaded.guard.ts
@Injectable({ providedIn: 'root' })
export class UsersLoadedGuard implements CanActivate {
  constructor(private facade: UsersFacade) {}
  canActivate(): Observable<boolean> { return this.facade.loading$.pipe(map(l => !l), take(1)); }
}
```
