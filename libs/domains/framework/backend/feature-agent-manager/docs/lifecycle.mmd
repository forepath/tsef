sequenceDiagram
    participant User as Client
    participant HTTP as AgentsController<br/>(/api/agents)
    participant Service as AgentsService
    participant Repo as AgentsRepository
    participant DB as Database
    participant WS as AgentsGateway<br/>(namespace: /agents)
    participant MsgService as AgentMessagesService
    participant MsgRepo as AgentMessagesRepository
    participant Docker as DockerService

    Note over User,Docker: End-to-end lifecycle: create → connect/login → send command/chat → disconnect → delete

    rect rgb(230, 240, 255)
        Note over User,Docker: Step 1 - Create Agent (HTTP)
        User->>HTTP: POST /api/agents { name, description? }
        HTTP->>Service: create(createAgentDto)
        Service->>Service: generatePassword()
        Service->>Service: hashPassword(password)
        Service->>Service: generateVolumePath()
        Service->>Service: isSshRepository(GIT_REPOSITORY_URL)
        alt HTTPS Repository
            Service->>Docker: createContainer(name, env, volumes)
            Note over Docker: Container created with:<br/>- GIT_REPOSITORY_URL<br/>- GIT_USERNAME<br/>- GIT_TOKEN/GIT_PASSWORD<br/>- CURSOR_API_KEY<br/>- Volume: /opt/agents/{uuid} -> /app
            Docker-->>Service: containerId
            Service->>Docker: createNetrcFile(containerId)
            Note over Docker: Creates /root/.netrc with:<br/>machine {domain}<br/>  login {username}<br/>  password {token}
            Docker-->>Service: .netrc created
        else SSH Repository
            Service->>Service: prepareSshKeyPair(GIT_PRIVATE_KEY)
            alt GIT_PRIVATE_KEY not set or invalid
                Service-->>HTTP: BadRequestException
                HTTP-->>User: 400 Bad Request
            else GIT_PRIVATE_KEY valid
                Service->>Docker: createContainer(name, env, volumes)
                Note over Docker: Container created with:<br/>- GIT_REPOSITORY_URL<br/>- GIT_PRIVATE_KEY<br/>- CURSOR_API_KEY<br/>- Volume: /opt/agents/{uuid} -> /app
                Docker-->>Service: containerId
                Service->>Docker: configureSshAccess(containerId, url, GIT_PRIVATE_KEY)
                Note over Docker: Detects key type and creates<br/>/root/.ssh/{id_rsa|id_ed25519|id_ecdsa}<br/>and configures known_hosts
                Docker-->>Service: SSH configured
            end
        end
        Service->>Docker: sendCommandToContainer(containerId, "git clone {url} /app")
        Note over Docker: Clones repository directly<br/>into /app (workdir)
        Docker-->>Service: repository cloned
        Service->>Repo: create(entity)
        Repo->>DB: INSERT agent
        DB-->>Repo: agent entity
        Repo-->>Service: agent entity
        Service-->>HTTP: CreateAgentResponseDto { id, name, password, ... }
        HTTP-->>User: 201 Created { id, name, password, ... }
    end

    rect rgb(200, 220, 255)
        Note over User,Docker: Step 2 - Connect (WebSocket)
        User->>WS: WebSocket Connect (namespace: /agents)
        WS->>WS: handleConnection(socket)
    end

    rect rgb(240, 250, 255)
        Note over User,Docker: Step 3 - Authenticate (WebSocket)
        User->>WS: login { agentId: id|name, password }
        WS->>Repo: findById(id)
        Repo->>DB: SELECT agent WHERE id
        alt Found by ID
            DB-->>Repo: agent entity
        else Not found by ID
            Repo-->>WS: null
            WS->>Repo: findByName(name)
            Repo->>DB: SELECT agent WHERE name
            DB-->>Repo: agent entity
        end
        Repo-->>WS: agent entity (uuid)
        WS->>Service: verifyCredentials(uuid, password)
        Service->>Repo: findById(uuid)
        Repo->>DB: SELECT agent WHERE id
        DB-->>Repo: agent entity
        Repo-->>Service: agent entity
        Service->>Service: verifyPassword(password, hash)
        alt Valid
            Service-->>WS: isValid: true
            WS->>WS: authenticatedClients.set(socket.id, uuid)
            WS->>Service: findOne(uuid)
            Service->>Repo: findById(uuid)
            Repo->>DB: SELECT agent WHERE id
            DB-->>Repo: agent entity
            Repo-->>Service: agent entity
            Service-->>WS: agent details
            WS-->>User: loginSuccess { success: true, data: {message, agentId, agentName}, timestamp }

            Note over WS,MsgRepo: Chat History Restoration
            WS->>MsgService: getChatHistory(uuid, 1000, 0)
            MsgService->>MsgRepo: findByAgentId(uuid, 1000, 0)
            MsgRepo->>DB: SELECT agent_messages WHERE agent_id ORDER BY created_at ASC
            DB-->>MsgRepo: message entities
            MsgRepo-->>MsgService: chat history
            MsgService-->>WS: chat history
            loop For each message (chronological order)
                alt User message
                    WS-->>User: chatMessage { from: "user", text: message, timestamp }
                else Agent message
                    WS->>WS: Clean & parse message
                    alt JSON valid
                        WS-->>User: chatMessage { from: "agent", response: {...}, timestamp }
                    else JSON invalid
                        WS-->>User: chatMessage { from: "agent", response: toParse, timestamp }
                    end
                end
            end
        else Invalid
            Service-->>WS: isValid: false
            WS-->>User: loginError { success: false, error: {message, code}, timestamp }
        end
    end

    rect rgb(250, 255, 240)
        Note over User,Docker: Step 5 - Send Command / Chat (WebSocket)
        User->>WS: chat { message }
        WS->>WS: uuid = authenticatedClients.get(socket.id)
        alt Not authenticated
            WS-->>User: error { success: false, error: {message, code}, timestamp }
        else Authenticated
            WS->>Service: findOne(uuid)
            Service->>Repo: findById(uuid)
            Repo->>DB: SELECT agent WHERE id
            DB-->>Repo: agent entity
            Repo-->>Service: agent entity
            Service-->>WS: agent details

            Note over WS,MsgRepo: Check for Initialization Message
            WS->>WS: Check if agentsWithFirstMessageSent.has(uuid)
            alt First message not sent
                WS->>MsgService: getChatHistory(uuid, 1, 0)
                MsgService->>MsgRepo: findByAgentId(uuid, 1, 0)
                MsgRepo->>DB: SELECT agent_messages WHERE agent_id ORDER BY created_at ASC LIMIT 1
                DB-->>MsgRepo: message entities
                MsgRepo-->>MsgService: message entities
                MsgService-->>WS: chat history
                alt No chat history exists
                    WS->>Repo: findById(uuid)
                    Repo->>DB: SELECT agent WHERE id
                    DB-->>Repo: agent entity with containerId
                    Repo-->>WS: agent entity
                    alt Container exists
                        WS->>Docker: sendCommandToContainer(containerId, command, instructions)
                        Note over WS: instructions = system context<br/>(command & rules system, message handling)
                        Docker->>Docker: Execute command and capture output
                        Docker-->>WS: (response ignored, not persisted)
                        WS->>WS: agentsWithFirstMessageSent.add(uuid)
                        WS->>WS: Log: "Sent initialization message"
                    end
                else Chat history exists
                    WS->>WS: agentsWithFirstMessageSent.add(uuid)
                end
            end

            Note over WS,MsgRepo: Persist User Message
            WS->>MsgService: createUserMessage(uuid, message)
            MsgService->>MsgRepo: create({agentId, actor: "user", message})
            MsgRepo->>DB: INSERT agent_messages
            DB-->>MsgRepo: message entity
            MsgRepo-->>MsgService: message entity
            MsgService-->>WS: message entity

            WS->>WS: server.emit('chatMessage')
            WS-->>User: chatMessage { success: true, data: {from: "user", text: message, timestamp}, timestamp }
            WS->>Repo: findById(uuid)
            Repo->>DB: SELECT agent WHERE id
            DB-->>Repo: agent entity (containerId)
            Repo-->>WS: agent entity
            alt Container exists
                WS->>Docker: sendCommandToContainer(containerId, command, message)
                Docker->>Docker: Execute command and capture output
                Docker-->>WS: agentResponse (JSON string)
                alt Response exists
                    WS->>WS: Clean response (remove before { and after })
                    WS->>WS: toParse = cleaned string
                    WS->>WS: Try JSON.parse(toParse)
                    alt JSON valid
                        Note over WS,MsgRepo: Persist Agent Message (parsed)
                        WS->>MsgService: createAgentMessage(uuid, parsedResponse)
                        MsgService->>MsgRepo: create({agentId, actor: "agent", message: JSON.stringify(parsedResponse)})
                        MsgRepo->>DB: INSERT agent_messages
                        DB-->>MsgRepo: message entity
                        MsgRepo-->>MsgService: message entity
                        MsgService-->>WS: message entity

                        WS->>WS: server.emit('chatMessage')
                        WS-->>User: chatMessage { success: true, data: {from: "agent", response: {...}, timestamp}, timestamp }
                    else JSON invalid
                        Note over WS,MsgRepo: Persist Agent Message (cleaned string)
                        WS->>MsgService: createAgentMessage(uuid, toParse)
                        MsgService->>MsgRepo: create({agentId, actor: "agent", message: toParse})
                        MsgRepo->>DB: INSERT agent_messages
                        DB-->>MsgRepo: message entity
                        MsgRepo-->>MsgService: message entity
                        MsgService-->>WS: message entity

                        WS->>WS: server.emit('chatMessage')
                        WS-->>User: chatMessage { success: true, data: {from: "agent", response: toParse, timestamp}, timestamp }
                    end
                end
            end
        end
    end

    rect rgb(255, 220, 220)
        Note over User,Docker: Step 6 - Disconnect (WebSocket)
        User->>WS: WebSocket Disconnect
        WS->>WS: handleDisconnect(socket)
        WS->>WS: authenticatedClients.delete(socket.id)
    end

    rect rgb(255, 230, 255)
        Note over User,DB: Step 7 - Delete Agent (HTTP)
        User->>HTTP: DELETE /api/agents/{id}
        HTTP->>Service: remove(id)
        Service->>Repo: delete(id)
        Repo->>DB: DELETE agent WHERE id
        DB-->>Repo: success
        Repo-->>Service: success
        Service-->>HTTP: void
        HTTP-->>User: 204 No Content
    end
